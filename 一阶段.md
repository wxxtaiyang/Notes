## 一阶学习目标

​	1、了解java的核心语法

​	2、开拓编程思维（实现需求的思维）

​	3、了解面向对象（OOP）

​	4、了解企业规范以及开发方式

## 里程碑

​	1、java核心语法

​	2、面向对象的编程思路

​	3、Swing UI相关编程

环境变量：将一个程序设置为到处可用。

## Java语言了解

​	Java是什么：Java是一门编程语言（计算机能够识别的语言）。可以编写应用程序和浏览器插件。有大量的企业化应用。

​	Java可以做什么：编写游戏、搭建服务器、制作应用程序、编辑网页。

​	Java的特性：简单性、高安全性、可跨平台型、可移植性、健壮性

​	Java分类：J2SE（标准版，标准的应用开发，常用于企业级的应用服务开发）、J2EE（企业版，常用于开发企业级应用）、J2ME（微型片版，常用于手机上的开发）（ps：J2ME后被J2EE包含）

## Java开发环境

​	JDK：Sun公司提供的免费的Java软件开发工具包，包含很多Java程序开发的工具，最常用的是编译和运行工具。（用于程序员开发Java程序）

## Java程序运行机制

​	JDK：Java开发工具包（包含JRE）
​	JRE：Java运行环境（包含JVM）
​	JVM：Java运行的虚拟机

Java是一门面向对象的强类型的编译的高级语言。

.class是字节码文件、.java是源码文件。

（脚本语言：机器可直接识别并执行的语言。编译语言：机器无法直接识别，需要通过编译过程，编译为机器可识别语言才能被机器识别。）

Java代码运行流程：基础运行流程所以代码从上往下运行，同一行中从左往右运行，且 所以代码只执行一次。

## IDEA

项目结构：工作空间 --> project（项目空间）--> package（包）--> Java文件

## Java核心语法的内容

**Java语言基本元素**：标识符、关键字、常量、注释。

标识符：赋给类、变量或者方法的名字。

​			变量：int（变量类型） num（变量名） = 100（变量值）; （变量的声明）使用变量名取到变量值该过程称为变量的调用。
​		（ps：变量命名规则：可以大小写字母、数字、下划线、美元符号的任意顺序组合，但是不能以一个数字开始。变量命名规范：可违反的规则，不过会跟大众不同的一个非硬性规则。变量命名规范为：小驼峰）

关键字：已经被Java官方使用掉的名称。

常量：声明之后无法被改变的量。

注释：解释代码含义、让部分代码不再运行。语法：//（单行注释）、/* ... */：多行注释、/** ... */：文档注释

**Java数据类型**（Java中不同数据做的事情会不一样）分为基本数据类型和复合数据类型

**基本数据类型：**
**字节类型**：一字节整数  byte（8位、范围{-2^7，2^7-1}）
**短整型**：两字节整数  short（16位、范围{-2^15，2^15-1}）
**整型**：四字节整数  int（32位、范围{-2^31，2^31-1}）
**长整型**：八字节整数  long（64位、范围{-2^63，2^63-1}）
**浮点型**：四字节小数  float  （32位、范围 1.401298e-45 ~ 3.402823e+38）
**双精度浮点型**：八字节小数  double（64位、范围 4.9000000e-324 ~ 1.797693e+308）
**字符型**：两字节字符  char（16位，范围除了\ 都可以当成一个字符）
**布尔型**：布尔真假数  boolean（-、范围 true或者false）
（数字类型默认为int、浮点类型默认为double、运算符计算后默认返回int、类型转换时大字节转小字节需要强制转换、字符串String不是基本数据类型）

## 变量的命名规范

1、Java变量命名只能使用字母、数字、下划线、美元符号($)组成。
2、变量名以字母、下划线或者美元符号开头，其中以美元符号开头命名的变量虽然能够编译通过但是不建议使用。
3、变量的名字可大小写混用，但首字符应小写。
4、Java变量名不限制长度，在命名的时候，尽量使用完整的单词进行命名，不要使用缩写（见名知意）。
5、变量名不可以和java关键字冲突，但是可以包含关键字。

驼峰式命名法：例子 --> stuInfoTable (单词之间相连，除了第一个单词其他首字母大写)
帕斯卡命名法：例子 --> stu_info_table(单词之间用下划线相连，全小写)

## 基本数据类型

**特殊类型**
boolean：只有true和false两个值
char：必须是单引号使用，并且只能有一个字符在其中（特殊字符：\t(制表：补全当前字符串长度到8的整数倍,最少1个最多8个空格,补多少要看你\t前字符串长度。)、\n(换行)、\b(退格)、\r(回车)、\f(进纸符)）
**整数类型**
byte：所占位数 8		数组范围 -2^7~2^7-1
short：所占位数 16    数值范围 -2^15~2^15-1
int：所占位数 32         数值范围 -2^31~2^31-1
long：所占位数 64      数值范围 -2^63~2^63-1 (特点默认long类型是int，除非在数字结尾加上L/l，一般是大写L，防止小写l太像1)
**浮点类型**
double：双精度浮点类型，直接写
float：单精度浮点类型，数值最后面需要加F/f大小写均可

## 数据类型的转换

**自动转换**：整形、实型、字符型数据可以混合运算。运算时不同数据类型的数据会转为最高优先级类型进行计算（短的类型变成长的类型）

**强制转换**：boolean不能参与其中、不能把对象类型转成不相关类的对象、把大容量的数据类型转为小容量的数据类型必须强制转换（转换过程中可能导致溢出或者损失精度）

## 作用域

作用域（Scope）决定了变量的使用范围

**全局变量**：变量可以在整个类中被访问

**局部变量**：变量只能在定义其的代码块中使用

## 运算符

1、算数运算符：+、-、*、/、%、++、--（++和--会根据书写位置决定是先计算还是增）

2、关系运算符：>、<、>=、<=、==、!=（两个等号才是等于的意思）

3、逻辑运算符：!、&&、||（非、短路与、短路或）

​		（ps：短路或（||）和短路与（&&）在多个条件判断时能在前几个得出结果时就会终止后几个的条件判断）

4、位运算符：>>、<<、>>>、&、|、^、~

5、赋值运算符：=、+=、-=、*=、/=

6、条件运算符/三目表达式：?  

Java的表达式：一个式子，由操作数和运算符构成的式子就是表达式。

## 流程控制语句

流程控制语句：即是可改变基础运行流程的控制语句。有两种分别为：分支语句、循环语句。

**分支语句**：

1、if语句：语法
if(条件){ 
	//当条件为true时执行的语句 
}

2、if..else语句：语法
if(条件){ 
	//当条件为true时执行的语句 
}else{
	//当条件为false时执行的语句
}

3、if...else if..else语句：语句
if(条件1){
	//当条件1为true时执行的语句 
}else if(条件2){
	//当条件2为true时执行的语句
}else if(条件3)...
else{
	//当y以上条件都为为false时执行的语句
}

（ps：条件是布尔值或者结果是布尔值的表达式）

4、switch语句：语法
switch(需要判断的变量){
	case 值1:	//当值1相等时执行的代码;break;
	case 值2:	//当值2相等时执行的代码;break;
	case 值3:	//当值3相等时执行的代码;break;
	...
	default:	//默认执行语句或者以上条件都不复合时执行的语句;	break;
}（break在中间作为跳出switch的关键字，某个分支中没有写break关键字时，将不再判断接着执行下面代码）
值1、值2、值3...这些值不能相同。switch小括号可书写的变量类型：JDK5时支持枚举类型以及byte、short、int、char以及其包装类；JDK7时支持String类型，不支持long以及其包装类

单一变量判断时建议使用switch判断语句、复杂的条件判断时建议使用if语句。

**循环语句**：当我们需要重复做某件同样的事情时就可以使用循环语句

1、for循环：语法

for(初始化变量; 范围判断; 增量){
	//循环体
}
for运行顺序：1.初始化变量 --> 2.进行范围判断（如果不符合范围结束循环）--> 3.执行循环体 --> 4.增量，然后返回第2步

2、while循环：语法

while(条件){
​	//当条件结果为true时执行的语句，直到条件不为true时结束while循环
}

while循环属于不确定次数的循环，要求执行到条件不成立为止

3、do..while循环：

do{
​	//当条件结果为true时执行的语句，直到条件不为true时结束while循环
}while(条件)

do while被称为后置判断循环；for与while被称为前置判断循环。差别就是后置判断会先执行一次后判断条件，前置判断先执行判断。

（ps：条件是布尔值或者结果是布尔值的表达式）

4、foreach循环：

输入使用Scanner 实现。一般来说要求用户输入之前必须先给用户一个提示（用户体验度）

## break、return、continue的区别

break：跳出所在的当前整个循环，到外层代码继续执行

return：直接返回函数，所有该函数体内的代码（包括循环体）都不会再执行

continue：跳出本次循环，从下一个迭代继续运行循环，内层循环执行完毕，外层代码继续运行

## Random类

生成随机数的工具类。

nextInt方法：作用是随机生成int范围内的一个整数。小括号内只能填写一个正整数，就可以让随机数在0~（该书数减1）的范围内。

## ==与equals

==：比较物理地址，基本类型比较时就可以使用该关系运算符

equals：比较复合类型的内容是否相等

## 数组（array）

概念：数组就是数据的集合。在Java当中还能起到一个变量名存储多个数值的方式。

数组的特性：声明完数组长度后，数组长度无法更改。

数组的声明：必须带中括号，证明他是一个数组

​	1、静态声明：在声明数组的时候直接初始化完成。
​			语法：type[] 数组名= {数值1,数值2,...}； 

​	2、动态声明：在声明数组的时候不直接初始化值，只定义其长度。
​			语法：type[] 数组名 = new type[长度]; 

数组的下标：就是数组内存储内容的序号。下标从0开始，最大到数组长度-1。

数组经常和循环使用，当看到数组的时候要联想到循环。

数组的长度：数组中存在一个length属性

## 多维数组

二维数组：把很多个一维数组放在同一个数组里面，就称为二维数组。

二维数组只带一个下标的时候还是一个数组（二维数组最大的特点就是要获取内容得两个下标）

第一个下标获取里面的具体的某一个数组，第二个下标获取那个数组里面的具体值

多维数组就是在一个数组里面存放多个数组，存放的数组里面可能也存在多个数组。

## Math类

数学运算的工具类

该工具类提供了数学的方法，其中有次方、根号等方法（运算符中不存在或者不存在的在数学中一些比较复杂的算法）。

## 函数/方法

概念：是一段具备特定功能的、高度封装的代码块。

函数的分类：内置函数、自定义函数

函数的使用：函数的声明、函数的调用（函数的声明不能再另外一个方法里面，即函数里面无法声明函数）

函数声明的五大要素：修饰符、返回值类型、函数名、参数列表、方法体

函数的调用：类名.函数名(参数);

(冗余代码中不同的地方）**参数的分类**：
	**形参**（形式参数，只负责占位，不参与具体内容）用于函数的声明过程中
	**实参**（实际存在的具备含义的参数）用于函数的调用过程中

参数可以存在多个，多个参数间使用逗号进行分隔。形参的顺序要和实参对应

<u>ps：声明了形参再调用函数的时候必须填写实参。</u>

如果函数给了返回值，那么调用该函数的地方需要接受该值；如果不接受，那么该数值则会丢失。return可返回数值且该关键字执行后函数无法接着执行。

基本数据类型作为形参传递，对形参进行修改不会影响实际参数。
引用数据类型作为形参传递，对形参进行修改会影响实际参数。

# 面向对象

对象：世间万物皆对象。意思就是世界上所有看的见摸得到的东西都可以成为对象。

描述一个对象：描述对象的特征（属性）、描述对象的行为（方法）
面向对象最大的好处在于模拟现实社会。

类：类相当于模板，决定了对象拥有那些属性和方法。（类是不能做事情的，类只是一个设计图）
类也是数据类型，并且是复合数据类型。

类是Java的核心和本质。它是Java语言的基础，因为类定义了对象的本质

类定义了一种新的数据类型，可以用新类型来创建该类型的对象。每个类都是一个新的数据类型。

类是对象的模板，而对象是类的一个实例

对象的方法内可以直接调用该对象的其他方法或属性。

1）对象中抽象出类
2）类通过实例化创建对象

面向对象：面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。

面向过程：面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；

面向对象的三大特性：封装、继承、多态

## 三大特性

**封装**：私有化属性，并提供公有得访问方法。
​	（this关键字：指向对象本身）

**继承**：子类拥有父类的非私有属性和方法，需要复合is-a关系才能够进行继承。继承中父类拥有共有特性，子类具有独特特性。

继承关键字：extends 放在子类类名之后，后面跟着父类的类名

继承最大的好处就是节省代码量。父类中静态的属性与方法无法被继承。

一个子类最多继承一个父类，一个父类可以被多个子类继承（爸爸只能有一个，儿子可以是多个）

如果过多使用继承，代码的耦合性就会过高（代码的开发追求：低耦合，高内聚）

继承下代码的执行顺序：父类静态代码块 --》子类静态代码块 --》父类构造函数 --》子类构造函数

如果父子类构造函数带有传参，子类构造函数在实例化的时候给予参数，父类构造函数在子类的构造函数中使用super关键字调用父类的构造函数传参。（super在子类中代表父类，可使用该关键字调用父类的属性和方法）

**多态**：多种形态的能力表述，也是继承的一种体现。

​	子类重写父类的方法，编写方法时使用父类的定义，运行时根据实际调用的子类去使用。

​	在父类中存在某一个方法没有方法体，且一定会被重写；那么可以使用接口。

## 修饰符

用来规定属性或者方法的访问权限。

**public**：公有的，所有包都可以访问

**protect**：受保护的，同包下以及其子类可访问

**default**：默认的，同包下可以访问

**private**：私有的，只有本类自己可以使用

## 构造函数

概念：是一种特殊的函数，没有返回值。并且方法名与类名相同的，最多只会执行一次的函数。

构造函数在对象实例化的一瞬间直接调用。通常用于初始化对象时赋值。

## 重载（overload）

在一个类中，方法名相同，但是参数列表或者返回值类型不同就被称为方法的重载。

重载的作用是方便用户在使用的时候，可以根据不同的情况执行不同的代码。最常用重载的是构造函数

重载中只看参数列表的不同，参数名不影响重载

## 覆盖/重写（override）

存在在子父类的继承中。父类中存在的某一个方法被子类重写（即子类定义一个与父类方法名和参数列表一致可能方法体不一致的方法），那么在实例化子类的时候调用该方法调用的是子类重写过的那个方法。

参数列表必须一样、返回值类型也一样、访问级别不能被重写的方法强、不能抛出新的异常、不能重写final和static的方法

## 抽象类

抽象类是一个类，写法时在类class前面加一个关键字：abstract

抽象类与其他类一致，但是抽象类中可存在抽象方法且抽象类无法被实例化。
抽象类必须被继承，继承后子类不是抽象类得重写抽象方法。
抽象类可实现接口，可以重写也可以不重写接口中的所有抽象方法。
抽象子类继承抽象类时也可以不重写抽象方法，等下一个子类不是抽象类时就得重写所有被继承的抽象方法。
抽象类中可以不写抽象方法，但是还是无法被实例化。

有方法体的方法叫：实例方法
没有方法体的方法叫：抽象方法

## 接口

一个Java接口是一些方法特征的集合，但是没有方法的实现。（即除了方法体的方法、还有权限修饰符必须为public之外，其他语法相同）即接口中的方法都是抽象方法。

接口时一个特别的抽象类，接口的写法是用：interface，不是class，前面也不用加abstract

接口被实现的时候必须重写所有该接口中的所有方法；
接口无法实现接口但是可以继承接口，子接口就包含了父接口的抽象方法；
接口中的变量均为静态常量，即接口中不存在成员变量，命名的变量均为静态常量
接口中的方法与常量均可不写权限修饰符，因为里面都是public公共的，所有可以不写。

接口被实现使用：implements关键字。

继承和接口的区别：继承体现血缘关系、接口体现社会关系、同一个类可以实现多个接口但只能继承一个父类。

#### 抽象类和接口的使用场景

​	① 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。

​	② 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。

**抽象类使用场景**：既想约束子类具有共同的行为（不在乎其如何实现），又想拥有缺省的方法，又能拥有实例变量

**接口使用场景**：约束多个实现类具有统一的行为；作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识；实现类需要具备很多不同的功能，各个功能之间可能没有任何联系；使用接口的引用调用具体实现类中实现的方法。

## MVC设计模式

设计模式可以理解成被之前总结好而产生的套路

M：mode(模型层)、V：view(视图层)、C：controller(控制层)

模型层：用于放置实体类
视图层：用于放置界面信息
控制层：用于管理、逻辑相关内容

## 字符串：String、StringBuffer、StringBuilder

字符串：字符串是字符的序列，从某种程度上来说类似于字符的数组。

在Java中字符串是对象，对应的类是String类。对于字符串变量如果需要经常对它进行插入、修改操作，一般存放子StringBuffer类对象中。

字符串常用两个引号代表，本质是创建了一个字符串常量，不过编译器会帮我们自动转换为字符串对象。

StringBuffer与StringBuilder通常用于字符串优化，节省空间的。

StringBuffer：可变字符串、效率低、线程安全（synchronized）；
StringBuilder：可变字符序列、效率高、线程不安全；

方法：

​	charAt：返回指定索引处的 char值。
​	length：放回字符串长度
​	indexOf：作用是查找字符串是否存在，存在返回第一次出现的下标，不存在返回-1。查找过程中区分大小写。
​	concat：连接两个字符串
​	replace：指定字符串替换成其他字符串
​	substring：截取该字符串中某一个子串
​	toUpperCase：全转为大写字母
​	toLowerCase：全转为小写字母
​	equalsIgnoreCase：字符串比较，不考虑大小写

验证码用来识别出到底是机器人还是人类。

验证码特点：随机内容、数字和字母(大小写)、4或6位验证码、验证时候不区分大小写

## 基本类型的封装类

封装类：让基本数据类型也能够拥有的方法。

boolean  --》 Boolean
char         --》 Character
byte         --》 Byte
short       --》 Short
int            --》 Integer
long         --》 Long
float         --》 Float
double    --》 Double

## 异常处理语句

try/catch语句：try{ 
​									//可能发生异常的语句 
​							}catch(异常类型 变量名){ 
​									//捕获到的异常处理方法体 
​							}

try/catch/finally ：try/catch语句相似，在最后多一个finally包裹的语句块

throw ：抛出异常，在方法体内抛出自定义异常

throws ：抛出异常，在方法声明的时候抛出会出现的异常

## ArrayList集合

简单理解就是可变长度的数组，也有对应的下标和长度。

集合不能存放基本数据类型，必须可以使用基本数据类型的封装类

ArrayList初始化默认长度为10，当新元素要进来而ArrayList没有空余位置存放时会将自身增长至2倍(如 : 15 --> 30 )。这种增长方式可能会照成空间浪费。

集合常用方法：
add ：实现往集合添加元素
size ：获取集合的长度
get  ：根据指定的索引获取集合中的某个内容
remove ：删除集合中指定索引或者对象的某一个内容
clear ：清空集合内的所有对象
contains ：判断ArrayList集合是否包含某个元素或者某个集合
retainAll ：从ArrayList集合删除指定集合不包含的元素
trimToSize ：将此ArrayList实例的容量调整为集合的当前大小

## JavaUI

Swing框架：swing中所有内容依靠容器显示

最外围为：顶级容器、中间：中间容器、中间容器里面：组件

swing中所有内容基本都是 J 开头的。

自己写一个界面，实质是自己写个类继承JFrame；其实JPanel也可以这样被继承。

**顶级容器**

```java
//	JFrame可以放置中间容器和组件
JFrame myFrame = new JFrame();//顶级容器之一。界面刚创建出来的时候默认是不可见的
setSize(800,600);//设置窗口大小，单位：像素
setLocationRelativeTo(null);//设置位置 null居中
setTitle("标题");//设置标题
setJMenuBar(myBar);// 添加菜单
setResizable(false);// 设置窗口无法拉伸
setDefaultCloseOperation(EXIT_ON_CLOSE);// 设置默认关闭行为。
setVisible(true);//设置界面可见
```

```java
JMenuBar bar = new JMenuBar();// 这是菜单栏
JMenu menu = new JMenu("开始");// 这是菜单
JMenuItem item = new JMenuItem("新建");// 这是菜单项
// 菜单栏的添加是特殊的，使用的不是add，而是setJmenuBar
```

**中间容器**

```java
JPanel jp = new JPane();// 中间容器
setBackground(new Color(255,255, 220));// 设置背景色
paintComponent();// 设置背景图片，写在构造方法外
// JPanel可以放置中间容器和组件
```

**组件**

```java
JButton btn1 = new JButton();// 按钮组件
JLabel label = new JLabel();// 文字图标
JTextField myfield = new JTextField();// 单行输入框
// 文件后缀名不要直接修改，如果真想改要用工具转化
// 组件设置大小
setLocation();// 设置坐标
setSize();// 设置大小
setBounds();// 设置大小和坐标
```

```java
ButtonGroup bg = new ButtonGroup();// 按钮组，将单选框放置其中表示它们是一组的，实现单选
JRadioButton rad1 = new JRadioButton("大专");// 单选框
// 如果不用ButtonGroup包裹单选框无法实现单选
```

**Swing菜单**

在顶级容器中设置菜单。

菜单结构：最外面：菜单栏、中间：菜单、最里面：菜单项

**布局**

用于管理组件位置的方式。

由中间容器设置布局因为组件在中间容器中。

矢量图：没有像素无论如何放大，都不会出现锯齿

1、自由布局 ：setLayout(null);	所有组件不会有默认位置和大小所以不能显示；所以要自己设置组件的位置和大小

2、流式布局：FlowLayout。为JPanel的默认布局。将组件一排排的放置，如果放不下自动往下移动。

​		FlowLayout构造函数可以放置三个参数：对齐方式、水平间距、竖直间距

3、边界布局：BorderLayout。将组件放到上、下、左、右、中五个区域上。优先满足上下左右，剩下的给中。不同界面大小中，上下的高度不变，左右宽度不变；因此在修改时上下只有高度，左右只有宽度。

​		BorderLayout构造函数可以放置两个参数：水平间距、竖直间距

4、网格布局：GridLayout。让组件呈现网格的效果，优先满足行数。会占满宽度和高度。

​		GridLayout构造函数可放置四个参数：行(优先)、列、水平间距、竖直间距

5、卡片布局：CardLayout

（ps：如果不是自由布局，setLocation()、setSize()、setBounds() 都无法生效，得使用setPreferredSize设置大小）

## Java事件处理模型

能够让java感知到的一件事事情，就被称为java事件

授权事件模型：事件源、监听器。

![image-20220926170627706](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220926170627706.png)

swing中，事件源通常是各个组件。

1、鼠标事件

2、键盘事件

**事件设置的顺序**

1、创建事件源

2、创建监听器类

3、实例化对应监听器

4、给事件源注册监听器

监听类 可以使用接口实现监听效果，也可以使用抽象类实现效果。

动作监听：actionListener，没有抽象类，因为接口中也只有一个方法。

actionCommand：动作指令，给组件进行设置。

因为所有组件都走相同监听，但是具体做什么事就要靠对应的信息来判断。

e代表事件对象。事件对象用于记录事件发生的一瞬间有哪些属性。

菜单项中安装监听和按钮完全一致。

**窗口监听**

```java
setDefaultCloseOperation(EXIT_ON_CLOSE) //点X的时候退出程序
setDefaultCloseOperation(HIDE_ON_CLOSE) //点X的时候隐藏
setDefaultCloseOperation(DO_NOTHING_ON_CLOSE) //点X的时候啥都不干
```

**定时器**

隔一段时间，重复做某件事。

我们是使用swing的定时器，所有要依赖swing界面。

## final关键字

被final修饰后的变量再赋值后无法被修改。被final修饰后的方法可以被继承无法被重写。

## static关键字

static关键字意为静态。静态代码块中无法调用非静态变量。静态属性或者方法在使用的时候无需实例化对象，即静态的属性与方法与类相关，与对象无关。

## 递归

递归就是函数调用自身。不要乱用递归，因为会导致：堆栈溢出

每次递归之后，最好纪律性给一个return结束函数。

## 异常

通常没有问题，但是遇到意外情况导致无法运行就被称为：异常

错误是在编译的时候可发现的。

一旦出现异常，不是让程序直接中断，而是让程序能过跳过异常，继续执行

断点调试：用于程序在运行过程中查看变量和数据的变化

Exception属于异常的总父类

ArrayIndexOutOfBoundsException：数组下标越界异常。

InputMismatchException：输入不匹配异常

StringIndexOutOfBoundsException：字符串数组下标越界异常

NullPointerException：空指针异常

## 常量

声明后不会再改变的量，即为常量。语法：public static final 数据类型 常量名

常量的名称一般都是大写，且常量声明后无法修改，在声明过程中不支持只声明不赋值。

常量通常声明在接口中。

## 打地鼠游戏

分析思路：
	1、初始化地图	
	2、放置老鼠	
	3、渲染地图
​	4、打老鼠	
​	5、判断是否打中老鼠

地鼠：属性{X坐标，Y坐标}、方法{随机自身坐标}

玩家：属性{血量，积分，X坐标，Y坐标}、方法{输入坐标打老鼠}

控制者对象：属性{地鼠，玩家，地图}、方法{初始化地图，放置老鼠，绘制地图，提示打老鼠，判断打中}

拓展性：为项目后期的功能呢扩展做好准备。

**出问题怎么解决**

1、定位问题，打印数据查看数据是否合理

2、分析问题，猜为啥出现问题

3、多尝试

**打地鼠主界面**

1、添加老鼠进入地图

​	本质就是把老鼠图片放入页面中

​	背景绘制中，可能导致图片被覆盖注意前后顺序

2、老鼠的位置 是随机出现在某个地洞中

```java
Rectangle mousRec = new Rectangle();// 矩形
```

**游戏的bug**

1、游戏没开始就可以打

​	在controller里面设置一个boolean值，判断是否开始

2、一只老鼠可以被打多次

​	在老鼠里面设置一个boolean值，判断是否被打过了

3、游戏倒计时和积分

## 登录/注册

**注册**

1、提示用户输入信息
2、利用Scanner获取输入信息
3、判断密码和确认密码是否相同
4、判断账号是否重复
5、存储账号和密码
6、提示注册成功

**登录**

1、输入账号密码

2、比较验证码

3、比较账号和密码（不要太具体的提示）

4、提示登录成功或者失败

登录后有个需求：根据登录的成功或者失败对应游戏是否开始。

登录的结果要让外部得知所以要返回值
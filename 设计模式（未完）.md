## 23种设计模式

面向过程编程 ---------------------> 编程思想：数据结构和算法

面向对象编程 ---------------------> 编程思想：23种设计模式 

### 单例设计模式

程序运算中有且仅有一个类的对象实例存在。

实现方式：让其他类无法重新实例化对象，只要将构造函数私有化，然后提供公有的方法使其去获取到该类实例化后的对象。

​		懒汉模式：只有在用户使用的时候才去创建该对象（可能会减少资源浪费，不过运行速度相对饿汉会慢一点。第一次如果有多线程同							时调用方法可能存在并发问题）

​		饿汉模式：类加载的时候就直接创建该对象，无论其他类是否使用到（可能会增加资源，不过运行速度相对懒汉会快一点）

​		实现步骤：

​					1、私有化构造函数（使其他类无法实例化该类的对象）

​					2、提供公有化的方法获取实例（该方法为静态，无法实例化即无法与获取对象，所有需要使用static关键字使其与对象无关，与类相关，可以通过类直接调用）

### 工厂设计模式

简单工厂模式(Simple Factory Pattern)：属于类的创新型模式，又叫静态工厂方法模式(Static FactoryMethod Pattern),是通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。简单工厂模式严重违背了“开闭原则”，难以拓展。

工厂方法模式(Factory Method)：定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。

抽象工厂模式(Abstract Factory Pattern)：是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

### 代理设计模式

为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象。

代理模式分为动态代理和静态代理

​		静态代理：被代理对象与代理对象需要一起实现相同的接口或者继承相同的父类。

​				优点：在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展

​				缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类
​							一旦接口增加方法，目标对象和代理对象都要维护

​		动态代理：代理对象不需要实现接口，但是目标对象需要实现接口，否则不能用动态代理

​							代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象

​							动态代理也叫：JDK代理、接口代理

### 装饰设计模式

动态的给一个对象添加一些额外的功能。与代理模式相似，不过与代理模式不同的是代理模式关注的是控制对对象的访问；装饰模式关注在一个对象上添加额外的方法。

使用场景：需要透明且动态的拓展类的功能时候就可以使用装饰设计模式。

实现方式：

​		装饰实现类通过实现要被装饰类的父类或者他本身，追加代码，然后再次调用倍装饰类自身的方法，完成对方法的透明且动态的添加额外功能。

### 适配器设计模式

适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

适用场景： 1、你想使用一个已经存在的类，而它的接口不符合你的需求。

​					2、你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。

​					3、（仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。

这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡

### 观察者设计模式

观察者模式又称为 发布-订阅模式，定义了对象之间**一对多依赖关系**，当目标对象(被观察者)的状态发生改变时，它的所有依赖者(观察者)都会收到通知。**一个观察目标**可以对应多个观察者，而这些**观察者之间没有相互联系**，所以能够根据需要增加和删除观察者，**使得系统更易于扩展，符合开闭原则**；并且观察者模式让目标对象和观察者松耦合，虽然彼此不清楚对方的细节，但依然可以交互，**目标对象只知道一个具体的观察者列表，但并不认识任何一个具体的观察者**，它只知道他们都有一个共同的接口。

但观察者模式的缺点在于如果存在很多个被观察者的话，那么将需要花费一定时间通知所有的观察者，如果观察者与被观察者之间存在循环依赖的话，那么可能导致系统崩溃，并且观察者模式没有相应的机制让观察者知道被观察对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。
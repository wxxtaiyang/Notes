# IO流

io流主要要分为：**输入流**和**输出流**、**字节流**、**字符流**、**缓冲流**、**转换流**、**对象流**、**打印流**。

​								输入和输出：基准是内存
​           					  数据进入内存：就叫输入
​            					 输出写出内存：就叫输出

字节流

​		InputStream（字节输入流），常用子类FileInputStream

​		OutputStream（字节输出流），常用子类OutputStream

字符流

​		Reader（字符输入流），常用子类FileReader

​		Writer（字符输出流），常用子类FileWriter

缓冲流：提高IO效率（IO次数减少）

​		BufferedInputStream（字节缓存输入流）、BufferedOutputStram（字节缓冲输出流）

​		BufferedReader（字符缓冲输入流）、BufferedOuputStram（字节缓冲输出流）

转换流：字节流转为字符流，其是字符流和字节流之间的桥梁。

​		InputStreamReader（字符转换输入流）、OutputStreamWriter（字符转换输出流）

对象流：间对象序列化后转为文件信息，反序列化回来重构成一个对象

​		ObjectInputStream（对象输入流）

​					注意事项：序列化后类文件不能改变，否则反序列化会报错；如果序列化后无法保证不修										改，可在类中添加一个常量 serialVersionUID

​		ObjectOutputStream（对象输出流）

​					注意事项：序列化对象必须时Serializable类型

​										成员变量也必须时Serializable类型

​										使用transient关键字修饰的成员变量不能序列化

打印流：

​		PrintStream（打印流，可打印任意数据类型）

# 三种网络编程的IO流

BIO：**同步并阻塞(传统阻塞型),面向流(Stram)**。服务器实现模式为一个连接一个线程，即用户端有连接请求时服务器就需要启动一个线程进行处理，如果这个连接不做任何事情就会造成不必要的线程开销，当然可以通过线程池机制改善。

NIO：**同步非阻塞，面向缓存区(Buffer)和通道(Channel)**。服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。

AIO： **异步非阻塞**，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。

**使用场景：**

- BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。
- NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。
- AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。

## BIO

同步阻塞IO流，服务器实现一个连接对应一个线程，如果这个连接阻塞的话，那就该线程无法做其他事。

## NIO

非阻塞IO，基于通道的IO操作。传统的IO操作将阻塞线程执行，线程在IO执行期间无法做任何事，而NIO可以配置socket为非阻塞模式。

**三大核心**：Channel（通道）、Buffer（缓冲区）、Selector（选择器）

​					**Channel(通道)**：NIO的通道类似流，但又有些不同:既可以从通道中读取数据，又可以写数												据到通道。通道可以非阻塞读取和写入通道，通道可以支持读取或写入缓												冲区，也支持异步地读写。

​					**Buffer(缓存区)**：缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。NIO												将其包装成NIO Buffer对象并提供方法便于访问该内存块。

​					**Selector(选择器)**：用于多个NIO通道检测，确定哪些通道可以进行读取和写入，使得一个													单独的线程可管理多个channel，从而管理多个网络连接。

Buffer中重要概念：

​		容量(capacity)：内存块的大小，不能为负，创建后无法修改

​		限制(limit)：缓存区可操作数据的大小（limit后数据无法读写）。限制不能为负，不能大于容量。

​		位置(position)：下一个要读写的数据索引，不能为符，不能大于其限制

​		标记(mark)与重置(reset)：标记事一个索引，通过标记指定一个特定position，然后调用reset恢														复到这个position。

​		标记、位置、限制、容量遵守以下不变式：**0<=mark<=position<=limit<=capacity**

Buffer常用方法

​			allocate(int capacity)：创建一个容量为capacity的（类型）Buffer对象

​			clear()：清空缓冲并返回对缓冲区的引用

​			flip()：为缓冲区的界限位置重置为0

​			capacity()：返回缓冲区大小

​			hasRemaining()：判断缓冲区中是否还有元素

​			limit()：返回Buffer的界限位置

​			mark()：对缓冲区设置标记

​			position()：返回当前位置，或者设置位置为n，返回修改Buffer对象

​			remaining()：返回当前位置到限制之间的元素个数

​			reset()：将position转为之前设置的mark所在位置

​			rewind()：间位置设为0，取消设置的mark

Buffer读写数据一般遵循以下四个步骤：

​		1、写入数据到Buffer

​		2、调用flip方法转为读取模式

​		3、从Buffer中读取数据

​		4、调用buffer.clear()方法或者buffer.compact()方法清除缓冲区

**直接与非直接缓冲区**

ByteBuffer可以是两种类型，一种是基于**直接内存（也就是非堆内存）**；另一种是**非直接内存（也就是堆内存）**。对于直接内存来说，JVM将会在IO操作上具有更高的性能，因为它直接作用于本地系统的IO操作。而**非直接内存，也就是堆内存中的数据**，如果要作IO操作，会先从本进程内存复制到直接内存，再利用本地IO处理。

从数据流的角度，非直接内存是下面这样的作用链：

​					**本地IO-->直接内存-->非直接内存-->直接内存-->本地IO**

而直接内存是：

​					**本地IO-->直接内存-->本地IO**

很明显，在做IO处理时，**比如网络发送大量数据时，直接内存会具有更高的效率**。直接内存使用**allocateDirect**创建，比申请普通的堆内存需要耗费更高的性能，这部分的数据是在JVM之外的，因此它不会占用应用的内存。一般来说，如果不是能带来很明显的性能提升，还是推荐直接使用非直接内存。isDirect()  方法判断是直接内存还是非直接内存。



通道（Channel）表示IO源于目标打开的连接，类似传统“流”。不过Channel本身不能直接访问数据，只能于Buffer进行交互。

通道于流的区别：

​			通道可以同时进行读写，而流只能读或者写

​			通道可以实现异步读写数据

​			通道可以从缓冲读数据。也可以写数据到缓冲

选择器（Selector）是SelectableChannele对象的多路复用器，可同时监控多个SelectableChannele的IO状况。选择器（Selector）是非阻塞IO的核心

## AIO

异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。

与NIO不同的是当要进行读写操作时直接API调用read或write方法即可，这两个方法均为异步。

​		对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区

​		对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序

​		即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。

四个异步通道：

​	AsynchronousSocketChannel

​	AsynchronousServerSocketChannel

​	AsynchronousFileChannel

​	AsynchronousDatagramChannel
## 二阶段起始

​		数据库+JDBC、IO流、网络通信、线程

## 数据库

数据库架构就是典型的---->客户端**Client**和服务器**Serve**r模式（C/S模式或C/S架构）

数据库的服务器：mysql服务

数据库的客户端：cmd（命令行的方式）、navicat（界面化）

数据库操作步骤

​	1、连接数据库：IP地址、端口号、用户名、密码

​				IP地址：表示执行的电脑的地址。本机可使用127.0.0.1（回路地址）或者localhost

​				端口：表示执行的电脑具体的通信交流的出口---->具体的某一个端口

​				账号：表示用户的使用权限，root表示超级管理员
​				密码：在安装数据库时设置，或者在安装后的其他时候添加的用户对应的密码

​	2、显示该mysql服务下的所有数据库

​				show databases;

​	3、创建自己的数据库

​				create database 数据库名称 character set 'utf8' collate 'utf8_bin'；---创建数据库

​				drop database if exists 数据库名； -----删除数据库 if exists判断数据库是否存在

​				use 数据库名；-----使用该数据库

​				show tables;  -----显示数据库下的所有表

​				desc 表名； -------查看该表的结构（字段名和字段类型）

​	4、创建表

​				create table 表名(

​							列名1	数据类型	其他...,(comment：注释、primary key：主键、auto_increment：自增)

​							列名2	数据类型	其他...,

​							......	

​							constraint 约束名 foreign key(列名) references  表名(列名)   	// 在创建表时添加外键约束

​				);

​				primary key  ----->    添加主键，唯一标识，用于判断数据重复。

​													一个表只能有一个主键，一个主键可以关联一个或者多个字段。

​				数据约束：

​								主键约束：不能有重复项

​								外键约束：子表中的外键值，在父表中一定存在

​								非空约束：not null

​								唯一约束：unique

​								自定义约束：自己定义规则约束表中项的值

​	5、删除表

​				drop table if exists 表名；

​	6、修改表

​				alter table 表名 操作

​				（约束：alter table 表名 constraint 约束写法、）

​	7、添加注释

​				comment添加注释关键字。在添加字段后或者表后写入加一对单引号可实现注释。

​	8、数据操作：增删改查

​					插入数据：insert into 表名(字段1，字段2，...) values(值1，值2，...),(值1，值2，...)....;

​					修改数据：update 表名 set 列1=值1，列2=值2，...	where 条件

​					删除数据：delete from 表名 where 条件

​					查询数据 select 列1,列2,...  from 表名  where 条件

**DDL**(Data Defined Language)：表和数据库等对象操作的SQL语句

**DML**(Data Manage Language)：对数据操作的SQL语句

**DCL**(Data Controller Language)：对数据的控制（权限）的SQL语言

### 查询

查询的分类：单表查询、联表查询、分组统计查询、子查询（嵌套查询）

**单表查询**：select 列1，列2，...  from 表名 where  条件
​								（显示列）		（指定表）     （控制行）

​					显示的列一定时表里存在的。（*：表示所有列）

​					条件运算符：=、>=、<=等

​					逻辑运算符：and、or

​					特殊运算符：like（模糊查询）、%（通配符）、between 值1 and 值2（判断区间闭区间）、is（是,判断值是否为空）、in(值，值2...) （在集合中存在）

​					排序：order by 默认升序asc 降序desc （写在where后面）

​					分页：limit start,size 查询从start开始size长度的数据 （写在最后面）

​					常见的函数：正常的函数----length、round、聚合函数----count、sum、avg、max、min

**联表查询**

​					表连接：left join...on（左连接 ）、right join...on（右连接）、inner join...on（内连接）。
​									存在两条相同记录可使用--distinct--关键字去除。

**分组统计查询**

​					group by 字段（分组）									

## Java对数据库操作

1、连接数据库 ---------------> Connection

​		连接所需参数：IP地址、用户名、密码、端口、数据库名称。Java将其组成一个字符串：url（同一资源定位符）

​		通过反射机制，加载其他数据库提供的jar文件（Driver）

2、SQL语句    ----------------> String

3、创建执行SQL的对象 ----> 执行者 PreparedStatement

​		执行者对象由连接数据库对象Connection提供

4、检测语法（预编译）-----> 方法 prepareStatement

​		通过预编译方法可生成PreparedStatement对象。

5、执行SQL语句  -------------> 方法 execute

​		executeUpdate：用于对数据修改时使用的方法，返回值int，表示被影响的行。

6、获取执行的结果 ----------> 方法的返回值：int ResultSet

​		ResultSet取值通过下标取值时，从 ***<u>1</u>*** 开始

7、关闭数据库连接（释放Java内存，解放数据库占用）---> 方法 close

 Java只提供一套连接数据库的接口，mysql需要实现这套接口。

​			任何数据库要实现这套接口都需要其对应的jar包

lib：用于存放jar包

bin：用于存放可执行文件

**通配符**

​		?：通配符符号，用于在Java中的SQL语句将要拼接的数据使用该符号表示。然后执行者执行之前通过set方法将SQL中的通配符使用变量值代替。（SQL语句中存在多个问号，通过下标表示哪一个问号，从**<u>*1*</u>**开始）

**finally关键字**

​	无论是否出现异常都会执行一次其中的代码块，即使再try中return，他也会执行。再finally中执行return语句发回的值也不会是finall中return的值。

## **反射机制**

​	Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为**动态语言的关键**。

​	使用反射的好处：用Java实现工具（如：框架、软件），提供给他人使用。

反射的源信息类：Class、Method、Field、Parameter、Type

```java
Class clazz = Class.forName("com.model.User");// 里面需要全类名(包名加类名，不加class)
// 通过反射获取当前类的属性
clazz.getDeclaredFields();// 获取所有属性，包括继承属性。Declared公开宣布。
// 通过反射获取当前类的所有方法
clazz.getMethods();
// 通过方式获取当前类实现的接口
clazz.getInterfaces();
// 通过反射获取但当前类的的父类
clazz.getSuperclass();
// 通过反射获取当前类带有泛型的父类
clazz.getGenericSuperclass();// Generic 通用的
// 通过反射获取当前类带有注解的父类
clazz.getAnnotatedSuperclass(); // Annotated 带注解的
// 通过反射获取当前类的构造函数
clazz.getConstructors();
// 通过反射动态创建当前类的对象
clazz.newInstance();
```

## 数据库+JDBC

封装的变换：方法----》类----》包

项目或者工程：-----------------------》jar文件

封装追求--独立性强、方便复用

代码追求：高内聚、低耦合

dao包 ------------------------>  数据访问层

bean包 ----------------------->  数据模块层

controller包 ---------------->  控制层

utils包 ------------------------>  工具包

view包 ------------------------>  视图包

service包 -------------------->  业务层

## 设计模式

面向过程编程 ---------------------> 编程思想：数据结构何算法

面向对象编程 ---------------------> 编程思想：23种设计模式 

**单例设计模式**：

程序运算中有且仅有一个类的对象实例存在。

实现方式：让其他类无法重新实例化对象，只要将构造函数私有化，然后提供公有的方法使其去获取到该类实例化后的对象。

​		懒汉模式：只有在用户使用的时候才去创建该对象（可能会减少资源浪费，不过运行速度相对饿汉会慢一点。第一次如果有多线程同							时调用方法可能存在并发问题）

​		饿汉模式：类加载的时候就直接创建该对象，无论其他类是否使用到（可能会增加资源，不过运行速度相对懒汉会快一点）

​		实现步骤：

​					1、私有化构造函数（使其他类无法实例化该类的对象）

​					2、提供公有化的方法获取实例（该方法为静态，无法实例化即无法与获取对象，所有需要使用static关键字使其与对象无关，与类相关，可以通过类直接调用）

**工厂设计模式：**

简单工厂模式(Simple Factory Pattern)：属于类的创新型模式，又叫静态工厂方法模式(Static FactoryMethod Pattern),是通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。简单工厂模式严重违背了“开闭原则”，难以拓展。

工厂方法模式(Factory Method)：定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。

抽象工厂模式(Abstract Factory Pattern)：是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

**代理设计模式：**

为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象。

代理模式分为动态代理和静态代理

​		静态代理：被代理对象与代理对象需要一起实现相同的接口或者继承相同的父类。

​				优点：在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展

​				缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类
​							一旦接口增加方法，目标对象和代理对象都要维护

​		动态代理：代理对象不需要实现接口，但是目标对象需要实现接口，否则不能用动态代理

​							代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象

​							动态代理也叫：JDK代理、接口代理

**装饰设计模式：**

动态的给一个对象添加一些额外的功能。与代理模式相似，不过与代理模式不同的是代理模式关注的是控制对对象的访问；装饰模式关注在一个对象上添加额外的方法。

使用场景：需要透明且动态的拓展类的功能时候就可以使用装饰设计模式。

实现方式：

​		装饰实现类通过实现要被装饰类的父类或者他本身，追加代码，然后再次调用倍装饰类自身的方法，完成对方法的透明且动态的添加额外功能。

## 集合

数据存储的最小单位是一个变量。变量：基本数据类型。

想要存储多个数据，就得使用数组或集合。数组存储的多个数据类型都是一致的。（数组和集合都是列表的形式存储，有下标；数组长度不可变，集合可变）

想要数据的永久性保留，则需要将数据存储在硬盘中。（文件、数据库）

集合的种类：Conllection：list（列表，有序，可重复，可为空）、set（集合，无序，不可重复，不为空）；Map：map（键值对，键值唯一）

**list集合：**

三个实现类：ArrayList、LinkedList、Vector

ArrayList：底层为数组，在内存空间中是连续的。因为其空间连续所有查改速度快。（每次扩大1.5倍）

LinkedList：底层为双向链表、在内存空间中可能是不连续的。因为其空间可能是不连续的，所有对数据的增删速度快。

Vector：底层为数组，在内存空间中是连续的。与ArrayList一致，但Vector被同步关键字修饰，所有Vector在可在多线程中使用。（每次扩大2倍）

**set集合**

三个实现类：HashSet、LinkedSet、TreeSet

​		HashSet：不保证元素的排列性、不是线程安全、元素可以是null、判断相等的标准通过hashCode与equals方法、存放在set中的对象一定要重写equals和hashCode方法。（底层是数组，初始容量16，使用率到0.75就会扩大为原来的2倍）

​		LinkedHashSet：HashSet的子类，根据hashCode来决定元素的存储位置。LinkedHashSet插入性能低于HashSet，LinkedHashSet不允许集合元素重复。（底层是双向链表）

​		TreeSet：可以确保集合元素除余排序、有两种排序方法（自然排序和定制排序）、有序，查询比list快。（底层是红黑树存储结构）

**map集合**

map接口常用的方法： put(key,value)：添加键值对

​										putAll(m)：将m中所有的键值对存放到当前map中

​										remove(key)：移除指定key的键值对，返回value

​										clear()：清空当前map中所有的数据

​										get(key)：获取指定key对应得value

​										containsKey(key)：是否包含指定key					

​										containsValue(value)：是否包含指定的value	

​										size()：返回map的键值对个数

​										isEmpty()：判断当前map是否为空

​										keySet()：返回所有key构成的Set集合

​										values()：返回所有value构成的Collection集合

​										entrySet()：返货所有键值对构成的Set集合

五个实现类：HashMap、LinkedHashMap、TreeMap、HashTable、Properties 

​		HashMap：通过哈希表映射值、允许null键值对，不保证映射顺序、所有key构成set集合、所有value构成Collection集合、判断key值相等是equals和hashCode方法、判断values相等时equals方法。（底层存储为链表，当链表数量大于8时变为红黑树）

​		LinkedHashMap：HashMap的子类、使用双向链表记录添加元素的顺序、可维护Map的迭代顺序，与插入顺序一致。（底层与HashMap一致，添加一堆双向链表）

​		TreeMap：需要根据键值对进行排序，保证键值对处于有序状态、排序方式（自然排序和定制排序）、判断key相等通过compareTo方法或者compare方法。（底层时红黑树结构）

​		HashTable：实现原理与HashMap相同、不允许使用null键值对。

​		Properties：Hashtable子类、用于处理属性文件、键值对数据类型都是String。

（Comparator：用于比较两个类大小，可通过重写conpareTo方法自定义设置类的比较方法）

## 集合提供的工具类

Collections工具类常用方法：（操作Set、List、Map集合的工具类）

```java
Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素
Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回 给定集合中的最大元素
Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素
Object min(Collection，Comparator)：根据 Comparator 指定的顺序，返回 给定集合中的最小元素
int frequency(Collection，Object)：返回指定集合中指定元素的出现次数
void copy(List src,List dest)：将src中的内容复制到dest中
boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值
reverse(List)：反转 List 中元素的顺序
shuffle(List)：对 List 集合元素进行随机排序
sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序
sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序
swap(List，int，int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换
```

Arrays工具类常用的方法：（操作数组的工具类）

```java
boolean equals(arr1,arr2)：判断两个数组是否相等
String toString(arr)：将数组转为字符串
String deepToString(arr)：深度转换数组，转为字符串 
void sort(arr)：从小到大排序
void fill(arr,fromIndex,toIndex,Object)：使用特定的Object替换数组原来元素值
int binarySearch(arr,Object)：通过二分法快速查找有序数组的值，返回下标，无则为负数
int compare(arr1,arr2)：按字典顺序比较两个数组，arr1大返回大于0，arr2大返回小于0
Object[] copyOd(arr)：赋值填充数组，返回该arr的数组
int mismatch(arr1,arr2)：查找并返回两个数组之间第一个不匹配的索引，如果未找到则返回-1
    
```

## 连接池

用空间换取时间效率，通过连接池减少使用数据库时的连接操作。

操作：1、配置文件

​			2、通过Druid工厂生成DataSoutce池子

​			3、获取连接

​			4、对应的数据库操作

​			5、关闭

## IO流

对电脑的磁盘中存储的文件进行操作。

Input（输入）和output（输出） 形式：流 -------------->  IO流

输入与输出的参照物为程序本身，对于程序读取磁盘文件为输入（input：程序拿到磁盘的数据）、对于程序写入东西到磁盘为输出（output：程序输出数据到磁盘）

IO流中有一套具体的对外实现类；如：文件实现类、网络的实现类等。

输入流与输出流的父接口：InputStream、OutputStream		

InputStream读取方法：read()	

OutputStream写入方法：write()

## 文件流

**FileInputStream**：

​		read()：读取一个字节，返回字节长度

​		read(byte[] bytes)：读取字节数组长度的字节到字节数组里面，返回读取长度

​		read(byte[] bytes,int off,int len)：从off开始读取len长度的字节到字节数组里面，返回读取长度

**InputStreamReader** ----> **FileReader**：

​		ready()：判断此流是否已经准备好用于读取，返回boolean值

​		read()：读取单个字符，返回int值

​		read(char[] cbuf,  int offset, int length)： 将字符读入数组的off开始的len长度。返回读取的字符长度

**FileOutputStream**：

​		write(int b)：将指定字节写入输出流中

​		write(byte[] b)：将数组长度的数组字节写入输出流中

​		write(byte[] b, int off, int len)：将指定 byte 数组中从偏移量 off开始的 len个字节写入此文件输出流。

​		flush()：刷新该流缓存，将输出流中数据写入文件

​		close()：关闭流，需要先刷新它

**OutputStreamWriter** ------> **FileWriter**：

​		write(int c)：写入单个字符

​		write(char[] cbuf,int off,int len)：从数组off开始写入len长度的字符到输出流中

​		write(String str,int off,int len)：从字符串off开始写入len长度的字符到输出流中

​		flush()：刷新该流缓存，将输出流中数据写入文件

​		close()：关闭流，需要先刷新它

**OutputStreamWriter **和 **InputStreamReader** 为Java IO提供的一个字节与字符转换的实现类

## IO流分类

流：Input（输入）、Output（输出）

字节流：InputStream ----> FileInputStream

​				OutputStream ----> FileOutputStram

字符流：Reader ----> FileReader

​				Writer ----> FileWriter

转换流：InputStreamReader

​				OutputStreamWriter

封装流：DataInputStream（字节封装）、BufferedReader（字符封装）

​				DataOutputStream（字节封装）、PrintWriter（字符封装）

## 文件操作

对文件操作，Java提供了一个类，可满足对于文件的操作。----- >  File类

常用方法

​				exists()：判断文件或者文件夹是否存在

​				isFile()：判断是否是文件

​				isDirectory()：判断是否是文件夹

​				isAbsolute()：判断是否有权限

​				getName()：获取文件名

​				getAbsolutePath()：获取路径，绝对路径

​				length()：获取长度，单位 b  (b-->kb-->mb-->gb-->tb-->pb...)

​				delete()：删除文件或者文件夹

​				createNewFile()：创建文件

​				mkdirs()：创建文件夹，父级文件夹不存在也可创建

​				list()：获取文件夹下的所有文件或者文件夹名称

​				listFiles()：获取文件夹下的所有文件或文件夹

​				renameTo()：重命名文件

## **网络**通信

网络编程三要素

​	协议：计算机网络通信必须遵守的规则

​	IP地址：：指互联网协议地址（Internet Protocol Address），Internet 上的每台主机(Host)都有一个唯一的IP地址。

​	端口号：网络的通信，本质上是两个进程（应用程序）的通信

UDP与TCP协议简介	

1. **UDP：**用户数据报协议(User Datagram Protocol)。UDP协议是一个面向无连接的协议。传输数据时，不需 要建立连接，不管对方端服务是否启动，直接将数据、数据源和目的地都封装在数据包中，直接发送。每个 数据包的大小限制在64k以内。它是不可靠协议，因为无连接，所以传输速度快，但是容易丢失数据。日常应 用中,例如视频会议、QQ聊天等。
2. **TCP：**传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前， 在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。 
   1. TCP连接的建立与终止：

     - 三次握手：TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在

       双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。

     ​			1. 第一次握手：客户端向服务器端发出连接请求，等待服务器确认。 

     ​			2. 第二次握手：服务器端向客户端回送一个响应，通知客户端收到了连接请求。

     ​			3.第三次握手：客户端再次向服务器端发送确认信息，确认连接。 

     - 四次挥手： 由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

       ​	第一次挥手：客户端发送关闭信息

       ​	第二次挥手：服务器接收信息并回应客户端收到请求。

       ​	第三次挥手：服务器再次发送关闭信息客户端

       ​	第四次挥手：客户端接收信息并再次返回确认关闭信息，然后等待一段时间	自动于服务器连接。服务端接收到客户端再一次确认信息关闭客户端连接。

     - 为什么要三次握手？
       为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

**TCP/IP通信协议：**

​		网络通信协议：网络协议为计算机网络中进行数据交换而建立的规则、标准或约定的集合。协议中对数据的传输格式、传输速率、传输步骤等做了 统一规定，通信双方必须同时遵守，最终完成数据交换。

​		TCP/IP协议： 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是 Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。（TCP/IP不是一个协议，而是一个协议族的统称。里面包括IP协议、IMCP协议、TCP协议。）

​		TCP/IP的4层模型

​		1、（数据链路层+物理层）：数据链路层实现了网卡接口的网络驱动程序，以处理数据在物理媒介（比如以太网、令牌环等）上的传输。

​		2、网络层：实现数据包的选路和转发

​		3、传输层：传输层为两台主机上的应用程序提供端到端（end to end）的通信。与网络层使用的逐跳通信方式不同，传输层只关心通信的起始端和目的端，而不在乎数据包的中转过程。

​		4、应用层：负责处理应用程序的逻辑。

**IP地址：**

IP地址分类：

- IPv4：是一个32位的二进制数，通常被分为4个字节，1字节一组，用十进制表示。例如 192.168.1.5 。

  IPv4分为五类：A--> 范围为1.00.1~126.255.255.254

  ​									子网掩码：255.0.0.0

  ​						   B--> 范围为：128.1.0.1~191.255.255.254

  ​									子网掩码：255.255.0.0

  ​						   C--> 范围为：192.0.1.1~223.255.255.254

  ​									子网掩码：255.255.255.0	

  ​						   D--> 范围为：224.0.0.1~239.255.255.254

  ​										不区分网络地址和主机地址

  ​						   E-->  范围：240.0.0.1 ~ 255.255.254

  ​										不分网络地址和主机地址，测试使用

- IPv6：是一个128位的二进制数，每16个字节一组，分成8组十六进制数。如：240e:379:5000:f300:b779:1403:9685:64a4

**端口：**

1. 端口:在计算机中，不同的应用程序通过端口号来区分，通过IP地址连接到计算机后，如果想要访问计算机中的某个应用程序，还需要指定的端口号。
2. 端口号：一般是指TCP/IP协议中的端口，端口号的范围从0到65535，如用于浏览网页服务的80端口，用于FTP服务的21端口，
3. 查看计算机哪些端口正在使用，在控制台输入：netstat -n

## 网络编程

socket（套接字）所有语言网络编程所需要的接口。

服务器实现步骤：

​		1、创建服务器，给定未使用的端口号，默认TCP协议

​		2、监听接受连接,返回连接的socket对象

​		3、接受消息

​		4、应答消息

​		5、 关闭流

​		6、关闭当前连接对象

​		7、关闭服务器

客户端实现步骤：

​		1、创建客户端，连接服务器：IP地址，端口号 默认TCP协议

​		2、发送信息,通过字节输入流发送

​		3、接受返回信息

​		4、关闭IO流

​		5、关闭客户端

socket程序运行时可能会出现IO流阻塞。（BIO 阻塞式IO、NIO 非阻塞式IO、AIO 异步IO）

**Socket连接问题**

1、当客户端先启动时，socket无法连接到服务器，会导致socket无法连接发送异常。

​	解决方案：然客户端一直尝试连接服务器，当连接上的时候关闭服务器。可在右下角或者左下角做文字提示。

2、在连接过程中客户端和服务器连接出现异常。

1）客户端无法知晓服务器是否出现异常。

​	解决方案：客户端隔一段时间询问服务器是否在线。如果对方连续未应答次数超过5次，证明连接断开。关闭当前线程，打开连接线程

2）客户端知晓服务器出现异常时，结束当前线程，开启连接线程

客户端的健壮性

1、断线重连

2、实时检测网络的连通性。（心跳线程）

3、网络断了，会触发readline异常。读取为空或者被catch捕获

## 线程

**进程**：指一个内存中运行的应用程序，拥有自主独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位。

​	进程被创建时会自带一条线程：主线程。

​	进程的状态切换，如：激活、休眠、阻塞等；速度慢、资源消耗多。

**线程**：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程，没有自己独立的内存空间。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。

​	主线程：执行主方法的线程。

进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。所有要让一个程序存在多个可执行任务可使用多线程实现。多线程为并发执行。

**创建线程类：**

​	通过继承Thread、实现Runnable接口（推荐。可避免单继承的局限性，降低程序的耦合性）

**创建新线程：**

​	通过start会创建新的线程，然后该线程会执行run方法里面的代码。

**并发与并行**

1.并发：指两个或多个事件在同一个时间段内发生（交替做不同的事情）

2.并行：指两个或多个事件在同一时刻发生（同时做不同事情的）

**线程的调度：**

​	 分时调度：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。

​	 抢占式调度：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。

**线程的生命周期：**

**新建**：创建线程，未开启该线程

**就绪**：执行了start，线程被创建，等待CPU使用权

**运行**：就绪的线程获取CPU，执行程序代码

**等待**：调用wait方法，得另一个线程使用notify或notifyAll方法去唤醒

**睡眠**：通过sleep方法进入休眠

*挂起：执行suspend方法，已过时*

**阻塞**：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。

**死亡**：线程方法执行完毕，或者执行stop停止调用。

阻塞分为三种：等待阻塞、同步阻塞（获取对象的同步锁时，该锁被其他线程占用）、其他阻塞（执行sleep、join或IO请求时）。

## 线程安全

**多线程：** 一个线程（子线程），加入（join）到另一个线程（父线程）里，父线程一定会等待子线程结束后才结束。

​	当一个程序为多线程时，在程序运行时多线程间为并发执行；那么就会存在当多线程访问一个公共资源可能会产生资源调度错误（只对资源进行读操作不会发生，当有线程进行写操作时就会发生），即程序无法往我们预期结果执行。那这就是线程安全问题。

线程安全的解决方案：同步、异步

**同步：** 指程序在运行必须按部就班执行，从1走到最后，不能跳走。

**异步：** 指程序在运行时相对比较灵活，从1开走，可跳到其他地方先走其他数字，直到所有数字走完。

## 锁机制

#### 乐观锁 和 悲观锁

**悲观锁**：认为自己在使用数据时候肯定有其他线程过来修改数据，因此在得到数据时会先加锁，确保数据不会被其他线程修改。（synchronized和lock都是悲观锁）

​	**synchronized** ：同步阻塞关键字（悲观并发策略）。

​		修饰普通同步方法：锁是对象

​		修饰静态同步方法：锁是该类

​		修饰代码块，括号里面是对象：跟普通同步方法一样，锁的是对象

​		修饰代码块，括号里面是类：跟静态方法一样，锁的是类

​	**lock** ：同步非阻塞类（乐观并发策略，底层volatile关键字和CSA算法实现）

​		方法结束： lock()：获取锁，被其他线程占用，就等待。

​							tryLock()：尝试获取锁，获取成功返回true，失败false

​							tryLock(long time，TimeUnit unit)：一段时间内尝试获取，返回获取结果。

​							lockInterruptibly()：想当于将tryLock里面的time无限放大。

​							unlock()：解锁

**乐观锁**：认为自己使用数据时不会有别的线程修改数据，所有不会添加锁，只在数据更新的时候去判断之前有没有别的线程更改了这个数据。如果没有则将自己修改的数据写入，如果有则根据不同的实现方式执行不同的操作（报错或重试）。

​	乐观锁通过**无锁编程**实现，最常采用的**CAS算法**，Java原子类中递增操作就是通过CAS自旋实现。

​	CAS算法：三个操作数-->V（需要读写的内存指）、A（进行比较的值）、B(要写入的新值)。当V和A相等时，通过原子方式用新值B来更新V值。

​	原子操作：最小的操作步骤，即不可拆分。

悲观锁适合写操作多的场景，乐观锁适合读操作多的场景，乐观锁的吞吐量会比悲观锁高

#### 公平锁 和 非公平锁

**公平锁**：有多个线程按照申请锁的顺序来获取锁，就是说，如果一个线程组里面，能够保证每个线程都能拿到锁，例如：ReentrantLock（使用的同步队列FIFO）

**非公平锁**：获取锁的方式是随机的，保证不了每个线程都能拿到锁，会存在有的线程饿死，一直拿不到锁，例如：synchronized，ReentrantLock。

非公平锁性能高于公平锁，更能重复利用CPU的时间

#### 可重入锁 和 不可重入锁

可重入锁：也叫递归锁，在外层使用锁之后，在内层仍然可以使用，并且不会产生死锁

**不可重入锁**：在当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞

可重入锁能一定程度的避免死锁，例如：synchronized，ReentrantLock

#### 自旋锁

一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环，任何时刻最多只能有一个执行单元获得锁

不会发生线程状态的切换，一直处于用户态，减少了线程上下文切换的消耗，缺点是循环会消耗CPU

#### 共享锁 和 独享锁

**共享锁** ：也叫读锁，可以查看数据，但是不能修改和删除的一种数据锁，加锁后其他的用户可以并发读取，但不能修改、增加、删除数据，该锁可被多个线程持有，用于资源数据共享

**独享锁** ：也叫排它锁、写锁、独占锁、独享锁，该锁每一次只能被一个线程所持有，加锁后任何线程试图再次加锁都会被阻塞，直到当前线程解锁

#### 死锁

线程死锁是指由于两个或者多个线程互相持有对方所需的资源，导致这些线程处于等待状态，若无外力作用，它们都将无法再次推进。

#### 等待唤醒

wati()：睡眠。在同步块中，锁对象调用该方法，释放锁并将该线程进入休眠状态，放进该对象的锁池，可设置时间自动醒来或者等待他人唤醒。

notify()：唤醒。随机从锁池中唤醒一个持有相同锁对象的一个线程，如果没有则无事发生。

notifyAll()：唤醒全部。从锁池中唤醒所有持有锁对象的线程。

**设计理念** ---> 开闭原则：代码对扩展开发，对修改关闭。不要修改代码，而是添加代码（类）。

## 注解

注解（Annotation）：给类、方法、属性、参数、构造函数...添加注解

1、自定义注解：

​			注解类型：给类、方法、属性...使用的注解。@Target(ElementType.TYPE)

​			注解渲染策略：@Retention(RetentionPolicy.SOURCE)// 在源代码检测 // CLASS类加载时检测、RUNTIME运行时检测

​			可添加属性

2、检测注解

​		得到注解的类，通过该注解类可得到该注解类中的注解值。

​			
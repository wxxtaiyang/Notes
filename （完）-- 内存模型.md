# JVM内存模型

JVM又被分为三大子系统：**类加载子系统**、**运行时数据区**、**执行引擎**。JVM的运行时数据区就是我们常说的JVM存储数据的内存模型。平常我们常说内存模型，其实在Java工作中存在两大内存模型，一个是JVM的内存模型（就是堆，栈之类的）；还有一个就是Java线程工作的内存模型，Java工作的内存模型指的是主内存，工作内存。两个是不同的概念。

![img](https://img2020.cnblogs.com/blog/2027777/202005/2027777-20200504172351533-782688897.png)

### 运行时数据区

JVM运行时数据区就是我们所说的JVM内存模型。

**程序计数器：**（线程私有）

线程在运行期间，由于会触发CPU时间片资源抢夺情况，如果时间片突然被抢占，出现阻塞，程序计数器会帮忙记录下每个线程所执行到吓一跳字节码指令，等线程重新拿到时间片继续执行。

**虚拟机栈：**（线程私有）

每个线程在执行每个方法时都会创建一个栈帧，栈帧里面又会包扣一些局部变量表，操作数栈，方法出口等，每个方法从执行到执行完成，也就是完成我们的入栈和出栈过程。

**本地方法栈：**（线程私有）

在java代码中我们有时可以看到用native修饰的方法，这些方法并不由Java语言实现，而是Java区调用底层C++语言实现的，跟虚拟机栈有点类似，之不多执行native方法的线程栈帧。

**方法区**：（线程共享）

方法区主要存储时虚拟机加载的类信息（版本，字段，接口等），成员常量，静态变量等数据；其中又包扣一部风时运行时常量器，运行时常量池存放的是编译期间生成的符号引用，后面经过解析出来的直接引用也会存储在常量池中。

当虚拟机new指令时，会先根据这个指令的参数在常量池中定义到一个类的符号引用，如果定位不到则需要重新对这个类进行加载，解析和初始化，治理涉及class文件加载的7大过程。如果能找到符号引用，证明该类已经加载过了并会给该对象分配内存空间，调用构造方法进行初始化。

JDK1.8后，方法区被叫做元空间，并且内存大小不限JVM内存大小限制，直接使用计算机的直接内存，受计算机的内存大小限制。

**堆：**（线程共享）

堆时JVM最大的一块内存区域，主要存放程序中new出来的对象，并非所有对象都是在堆上进行分配，随着线程逃逸，标量替换等技术的发展，对象也有可能在栈上进行分配。

堆也是GC进行回收的主要区域，容易出现OOM（OutOfMemoryError）异常。

堆中又分为young（新生代），old（老年代）；分配内存比例1：2。新生代中的对象具有“朝生夕死”的特点（对象刚创建不久就会被回收掉）。而老年代中的对象具有特点则是不容易被回收掉，一些大对象比如数组就会存放在老年代中。是FullGC回收的主要区域。

新生代长又分为eden区，两个survivor区，分配比例8：11。程序中new对象首先会在eden区中进行分配，然后经过MinorGC，eden区没有被回收的对象又会被放在survivor Form区，survivor Form区经过GC后的对象没有别回收又会转移代survivor To区，这两个区的对象可以双向转移。新生代采用GC的算法是复制算法，两个survivor区正是复制算法要预留出来的区域。![img](https://img2020.cnblogs.com/blog/2027777/202005/2027777-20200504201559002-469373621.png)

### 类加载器（ClassLoader）

**作用**  ：ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。

**类加载分类**  ：显示加载、隐式加载。（加载class文件到内存的方式）

​		**显式加载**指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。

​		**隐式加载**则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。

**类加载器分类** ：

1、引导类加载器（Bootstrap）：负责加载bin路径下的核心类库，只加载包名Java、javax、sun开头的类。

2、扩张类加载器（ExtClassLoader）：负责加载lib\ext目录下的类库

3、系统类加载器（APPClassLoader）：负载加载classpath环境变量所指定的类库，用户自定义的默认类加载器。

AppClassLoader的父加载器是ExtClassLoader；ExtClassLoader的父加载器是Bootstrap；Bootstrap是根加载器**三者之间是没有继承关系的**。

![img](https://img2020.cnblogs.com/blog/2027777/202006/2027777-20200614152610110-1811024897.png)

**命名空间** ：

​		**类的唯一性**：对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。

​		命名空间：

​					每个类都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成。

​					在同一级命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类。

​					在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类。

**基本特性** ：

​		**双亲委派机制**：规定了加载顺序是，引导类加载器先加载，如果加载不了，由扩展类加载器加载，加载不了，由系统类加载器或者自定义类加载器进行加载（自底向上检查类是否被加载过，自上向下加载类）。

​		**可见性**：子加载器可以访问父加载器加载的类型，但是反过来是不允许的。否则，会因为缺少必要的隔离 无法利用类加载器实现容器的逻辑。
​		**单一性**：由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，都不会在子加载器中重复加载。但是注意，类加载器 “邻居” 间，同一类型仍然可以被加载多次，因为互相并不可见。

双亲委派机制可以被破坏的。

1、我们继承自ClassLoader，重写loadClass方法，里面的逻辑可以自己定义不采用双亲委派方法加载。但官方不提倡重写该方法，比较建议重写findClass()方法

2、双亲委派机制被破坏还有一个原因就是 Java自己本身存在一个缺陷，比如在加载数据库驱动的时候，Java只提供了java.lang.Driver接口，但是他的实现类是由数据库厂商去实现的，但是Bootstrap ClassLoader又无法加载这些实现类的代码，这时候父类加载器就会通过Thread.currentThread().getClassLoader()获取子类加载器去完成这些实现类的动作

### 类加载机制

**类加载过程** ：

类从被加载到JVM内存开始，到卸载出内存为止，生命周期可以分为：**加载** 、**验证** 、**准备** 、**解析** 、**初始化** 、**使用** 、**卸载** 。而验证、准备、解析三个阶段又可以统称位连接。

![img](https://img2020.cnblogs.com/blog/2027777/202006/2027777-20200614112207587-1833133923.png)

其中**加载、验证、准备、**和**初始化**这四个阶段执行的顺序是确定，唯一不确定的是**解析阶段**，**解析阶段**是可能会出现在初始化阶段之后发生的，这也是为了支持Java语言的**运行时绑定**(也被称为**动态绑定或晚期绑定**  也常常被称为**多态**)。

**加载** ：加载时整个过程的第一个阶段。虚拟机主要主要完成以下事情：

​		1、通过一个类的全限定名来获取定义此类的二进制字节流

​		2、将这个字节流所描述的静态存储结构化位方法区的运行时数据结构

​		3、在方法区中生成一个代表类的class对象，作为方法区这个类的各种数据的访问入口

**验证** ：验证阶段主要为了确保Class文件的字节流包含信息是否符合当前虚拟机的要求，不会危害虚拟机的安全。验证包扣：文件格式验证、元数据验证、字节码验证、符号引用验证。

**准备** ：准备阶段是为类的静态变脸分配内存空间，对其设置默认值。实例变量实在对象实例化时随着对象一起分配在Java堆内存中，并调用构造方法初始化。如果被final修饰的静态变量，默认值就是我们程序中所设置的值。

**解析** ：把类中的常量池内的符号引用转换为直接引用。比如方法的符号引用，是有方法名和相关描述符组成，在解析阶段，虚拟机把符号引用替换成一个指针，这个指针就是直接引用，它指向该类的该方法在方法区中的内存位置。

**初始化** ：对类的静态赋予正确的初始值，在准备阶段是给类的静态变量赋予默认值，在初始化阶段对静态变量赋予初始值。

​		初始化时机： 1、创建类的实例

​								2、使用java.lang.reflect包的方法对类进行反射调用时候

​								3、对类的静态变量进行访问或赋值

​								4、访问调用类的静态方法

​								5、初始化类的一个子类，会优先对其父类进行初始化

​								6、作为程序的入口，比如main方法

**类初始化顺序** ：

​			 		**Class.forName()**: 把类的.class文件加载JVM中，并会调用类的static静态代码快，比较常见的就是Class.forName("com.mysql.cj.Driver")加载mysql驱动时，经常会看到这个语句

​					**ClassLoader.loadClass():** 只是把.class文件加载到JVM中，并不会执行类中的static静态代码块

**对象的初始化顺序：静态变量/静态代码块 -> 普通代码块 -> 构造方法**

​    1. 父类**静态变量**和**静态代码块**（先声明的先执行）

​    2. 子类**静态变量**和**静态代码块**（先声明的先执行）

​    3. 父类**普通成员变量**和**普通代码块**（先声明的先执行）

​    4. 父类的**构造函数**

​    5. 子类**普通成员变量**和**普通代码块**（先声明的先执行）

​    6. 子类的**构造函数** 

### GC垃圾回收机制

#### **垃圾判断算法** 

垃圾收集器对内存中的对象回收前，首先要确定内存中对象是不是垃圾，那些对象是否还被引用。判断对象存活算法有：引用计数算法、可达性分析算法

​	**引用计数算法** ：给每个对象添加一个引用计数器，每当对象在其他地方引用时，计数器+1，引用失效时，计算器-1；当计算器为0时代表对象可以被回收了。

​		优点：实现起来简单，判断能否被回收也简单，效率快

​		缺点：无法解决对象之间循环引用的问题

​	**可达性分析算法** ：解决对象之间循环应用问题。基本思想就是通过被称为“GC ROOT”的对象作为搜索起始点，从这些节点开始向下搜索，搜索走过的路径被称为**引用链**，如果这些对象没有在这些引用链上，说明对象可被回收。

![img](https://img2020.cnblogs.com/blog/2027777/202006/2027777-20200607182314356-344449781.png)

可作为“GC ROOT”的对象包扣以下几种

​	1、栈帧中局部变量表引用的对象，也就是我们所new一个对象，然后将这个new出来的对象赋值给一个变量，这个变量可作为“GC ROOT”根节点

​	2、方法区中静态属性引用的对象，类中声明的静态成员变量

​	3、方法区只常量引用对象，用final修饰的成员变量

无论是引用计数算法还是可达性分析算法，都牵涉到了对象的引用，而在JDK1.2以后，Java又将引用分为了4种，分别是**强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)**

**强引用**：最常见的直接new对象引用。当该对象要被回收时切断变量与对象之间的强引用（变量为空），这时对象就会被回收

**软引用**：JDK给我们提供SoftReference对象来使用软引用，当内存充足情况下，对象就不会被回收。内存不足时软引用对象就会被垃圾回收![img](https://img2020.cnblogs.com/blog/2027777/202006/2027777-20200620175822190-1075179146.png)

**弱引用**：JDK给我们提供了WeakReference对象来使用弱引用。弱引用与与软引用的区别就是不管内存够不够只要发现弱引用对象，对象就会被回收![img](https://img2020.cnblogs.com/blog/2027777/202006/2027777-20200620180310743-620525328.png)

**虚引用**：虚引用时引用中最弱的一种关系，形同虚设。JVM一经发现就会被回收。

#### 垃圾收集算法

**标记清除算法** ：分为两个阶段--标记、清除。首先标记阶段，标记出所有可被回收算法，标记完成后在进行清除。将所有标记对象进行回收。

​	缺点：造成大量内存碎片、标记和清除两个阶段效率不高

**复制算法** ：为解决标记清除算法造成大量的内存空间碎片。思想：将内存划分成两块大小相同的内存空间，每次只是用其中一块。当一块内存使用结束后，将那块内存空间存活的对象复制到另外一块内存空间中，把使用过的内存空间清空，只需要复制对象指针，按顺序分配内存。

​	优点：不会产生内存碎片、回收效率高

​	缺点：浪费内存空间

**标记整理算法** ：标记清楚和复制算法所遗留下来的问题：(1) 产生内存碎片 (2) 内存空间的浪费。因为**老年代**的对象特点存活时间长，如果采用复制算法那么需要复制的对象就多，需要移动大量的复制对象指针，所以复制算法并不适用于老年代。标记整理算法思想是先让存活的对象都往一端进行移动，回收另一端对象。

​		标记整理算法适合老年代原因：  老年代回收次数少，整理过一次无法频繁整理

​																对象存活率高，不需要过多移动对象。

**分代算法** ：融合前三种算法思想，根据不同区域对象的特点而采用适当的手机算法

#### 垃圾收集器

垃圾收集器时垃圾收集算法的具体体现，一共有七种不同的垃圾收集器。

**Serial收集器** ：单线程垃圾收集器，执行GC时只会有一个线程去进行垃圾回收，用户线程会被暂停只到GC执行完成。

​						是一种新生代的收集器，采用的是复制算法。

**ParNew收集器** ：多线程垃圾收集器，充分利用CPU。该收集器还有一个特点就是除了Serial收集器外，只有ParNew收集器可以跟CMS收集器一起组合使用

​						是一种新生代的收集器，采用的是复制算法

**Parallel Scavenge收集器** ：多线程垃圾收集器，对新生代进行回收，也是采用复制算法。但是该收集器更加的关注可控制的吞吐量（吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间））。该收集器有两个参数控制吞吐量：一个是最大垃圾收集停顿时间、还有一个是设置吞吐量大小。

​						是一种新生代的收集器，采用的是复制算法

**Serial Old收集器** ：跟Serial收集器，单线程的，但是作用在老年代中，采用**标记整理算法**。

**Parallel Old收集器** ：是Parallel Scavenge收集器的老年代版本，采用**标记整理算法**。

**CMS收集器** ：该收集器关注尽可能的缩短垃圾收集时用户线程停顿的时间。作用在老年代，次啊用**标记清除算法**。运行过程分为四个阶段。1、初始标记。2、并发标记。3、重新标记。4、并发清除。四个阶段中只有**初始标记**和**重新标记**需要暂停用户线程。缩短了用户线程暂停时间。

![img](https://img2020.cnblogs.com/blog/2027777/202006/2027777-20200607214525441-1363310151.png)

​			缺点：对CPU资源非常敏感、采用标记清除算法会产生大量的内存空间碎片。

**G1收集器** ：G1收集器是目前既能回收新生代又能回收老年代的收集器。G1收集器采用的是**标记整理算法**。相对于CMS收集器不会产生内存空间碎片。还有一大特点就是**可预测停顿**。G1在追求低停顿外，还能建立可预测的提顿时间模型，能让使用者明确指定在一个长度M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。G1还可以设定GC暂停的时间，根据预测模型选取性价比收益更高。且将堆划分成一定数量的 Region(默认2048)，每个Region能回收多少是多少在设定的时间内。

G1收集器运行大致可分为四个步骤：1、初始标记。2、并发标记。3、最终标记。4、筛选回收

![img](https://img2020.cnblogs.com/blog/2027777/202006/2027777-20200607222738981-1985359316.png)

各收集器之间组合使用关系图：

![img](https://img2020.cnblogs.com/blog/2027777/202006/2027777-20200607223034939-276904331.png)

### JVM调优

jvm调优就是优化Full GC执行时间和执行次数，让Full GC尽可能的少发送。导致Full GC出现就是老年代空间不足。可通过以下几点来进行优化

1、当suvivor区容量不够时，会将对象存放在老年代中。可以设置合理的eden区survivor的比例大小，让对象尽量留在新生代中。可以使用-Xmn设置年轻代的大小。

2、对于占用内存比较大的对象，一般会优先选择老年代中分配内存。我么可以设置参数让一些大对象也分配在新生代中，设置参数-XX:PetenureSizeThreshold=1000000B，标明对象超过该数值存储在老年代中，否则放在新生代中。

3、年轻对象在eden区时，每次GC时，如果对象存活则该对象分代年龄会+1，达到默认值15时会被放在老年代中。设置参数-XX:MaxTenuringThreshold比较大的阈值，让对象尽量停留在年轻代中。

4、设置最小堆和最大堆：`-Xmx`和`-Xms`稳定的堆大小堆垃圾回收是有利的，我们应该将最大堆和最小堆设置成一样的，这样系统在运行时堆大小是恒定的，可以防止每次进行GC后，又得重新分配最小堆和最大堆。稳定的堆大小可以防止一个内存抖动的现象

5、通过增大吞吐量提高系统性能，可以通过设置并行垃圾回收收集器。

（1）`-XX:+UseParallelGC`:年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能的减少垃圾回收时间。

（2）`-XX:+UseParallelOldGC`:设置老年代使用并行垃圾回收收集器